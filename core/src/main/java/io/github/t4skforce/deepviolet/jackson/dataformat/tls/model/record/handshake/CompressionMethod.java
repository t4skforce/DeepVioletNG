package io.github.t4skforce.deepviolet.jackson.dataformat.tls.model.record.handshake;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import io.github.t4skforce.deepviolet.jackson.dataformat.tls.annotations.TlsCompressionMethod;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

/**
 * <br/>This class is based on <a href="https://www.iana.org/assignments/comp-meth-ids/comp-meth-ids.xhtml">www.iana.org</a> specification<strong>This class is generated by {@link io.github.t4skforce.deepviolet.generators.impl.TlsCompressionMethodCodeGenerator}.
 * DO NOT MODIFY!</strong><br/>
 *
 */
@TlsCompressionMethod
class CompressionMethod {
  public static final Date UPDATED = new Date(1616628074000L);

  private static final String NAME_FORMAT = "%s:(0x%04X)";

  private static final String UNASSIGNED = "UNASSIGNED";

  private static final String RESERVED = "RESERVED";

  private static final Map<Integer, CompressionMethod> VALUE_MAP = new HashMap<>();

  private static final Map<String, CompressionMethod> NAME_MAP = new HashMap<>();

  /**
   * Static variable for NULL compression.<br/>
   * <strong>References:</strong> <a href="https://www.iana.org/go/rfc5246">RFC5246</a>
   */
  public static final CompressionMethod NULL = new CompressionMethod(0x00, "NULL", false, false);

  /**
   * Static variable for DEFLATE compression.<br/>
   * <strong>References:</strong> <a href="https://www.iana.org/go/rfc3749">RFC3749</a>
   */
  public static final CompressionMethod DEFLATE = new CompressionMethod(0x01, "DEFLATE", false, false);

  /**
   * Static variable for LZS compression.<br/>
   * <strong>References:</strong> <a href="https://www.iana.org/go/rfc3943">RFC3943</a>
   */
  public static final CompressionMethod LZS = new CompressionMethod(0x40, "LZS", false, false);

  static {
    for (int i = 0x02; i <= 0x3F; i++) {
      new CompressionMethod(i, "Unassigned", true, false);
    }
    for (int i = 0x41; i <= 0xDF; i++) {
      new CompressionMethod(i, "Unassigned", true, false);
    }
    for (int i = 0xE0; i <= 0xFF; i++) {
      new CompressionMethod(i, "Reserved for Private Use", false, true);
    }
  }

  private int value;

  private String name;

  private boolean reserved = false;

  private boolean unassigned = false;

  private CompressionMethod(int value, String name, boolean reserved, boolean unassigned) {
    this.value = value;
    this.name = name;
    this.reserved = reserved;
    this.unassigned = unassigned;
    NAME_MAP.put(this.getName(), this);
    VALUE_MAP.put(this.value, this);
  }

  public int getValue() {
    return this.value;
  }

  @JsonValue
  public String getName() {
    if (this.unassigned) {
      return String.format(NAME_FORMAT, UNASSIGNED, this.value);
    } else if (this.reserved) {
      return String.format(NAME_FORMAT, RESERVED, this.value);
    } else {
      return this.name;
    }
  }

  @JsonCreator
  public static CompressionMethod of(int value) {
    return VALUE_MAP.get(value);
  }

  @JsonCreator
  public static CompressionMethod of(String name) {
    return NAME_MAP.get(name);
  }

  @Override
  public String toString() {
    return getName();
  }
}
